<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>TCC - Monitoramento Inteligente da Dressagem de Rebolos</title>

  <!-- Reveal.js v4.x estável -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/dist/reveal.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/dist/theme/black.css" id="theme" />
  
  <!-- Additional CDN Libraries for Animations -->
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  
  <style>
    html, body { background:#0d1117; }
    .reveal { background:#0d1117; color:#e6edf3; font-size:32px; }
    .reveal .slides { text-align:left; }
    .reveal .slide-background { background-image:none !important; background:#0d1117 !important; }
    .reveal section h1, .reveal section h2 { text-transform:none; color:#f0f6fc; }
    .reveal a { color:#79c0ff; }

    :root{
      --r-main-font: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      --r-heading-font: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      --r-heading-letter-spacing: 0.2px;
    }

    .reveal ul { line-height:1.4; }
    .reveal code { font-size:0.9em; }
    .reveal .progress { height:6px; }
    .reveal .footer{ display:none; }
    .badge{ display:inline-block; padding:2px 10px; border:1px solid #30363d; border-radius:999px; font-size:0.7em; color:#9da7b3; }
    .small { font-size: 0.8em; color: #9da7b3; }

    .two-col {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 40px;
      align-items: start;
    }
    .equation {
      background: #1a1a1a; padding: 15px; border-radius: 5px; margin: 10px 0;
      border-left: 4px solid #79c0ff; font-family: 'Courier New', monospace;
    }
    .methodology-step {
      background: #161b22; padding: 15px; margin: 10px 0; border-left: 4px solid #58a6ff;
    }
    .reference {
      font-size: 0.85em; line-height: 1.4; margin: 5px 0;
    }
    .slide-image {
      width: 100%; max-width: 800px; height: auto; margin: 20px 0; 
      border: 2px solid #333; border-radius: 5px; box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }
    .highlight-box {
      background: #1e2a3a; border: 2px solid #58a6ff; border-radius: 8px; 
      padding: 15px; margin: 15px 0;
    }

    /* Animation Styles */
    .animation-container {
      background: #1a1a1a; border-radius: 8px; padding: 20px; margin: 20px 0;
      border: 1px solid #333; position: relative; overflow: hidden;
    }

    .convolution-demo {
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      gap: 20px; align-items: center;
    }

    .matrix {
      display: grid;
      gap: 2px;
      background: #333; padding: 10px; border-radius: 5px;
    }

    .matrix-5x5 { grid-template-columns: repeat(5, 1fr); }
    .matrix-3x3 { grid-template-columns: repeat(3, 1fr); }
    .matrix-2x2 { grid-template-columns: repeat(2, 1fr); }
    .matrix-4x4 { grid-template-columns: repeat(4, 1fr); }

    .matrix-cell {
      width: 40px; height: 40px; background: #2d3748; 
      display: flex; align-items: center; justify-content: center;
      font-size: 12px; font-weight: bold; border-radius: 3px;
      transition: all 0.3s ease;
    }

    .matrix-cell.active { background: #f56565; transform: scale(1.1); }
    .matrix-cell.highlight { background: #48bb78; }

    .convolution-filter {
      font-size: 24px; color: #79c0ff; text-align: center;
      padding: 20px; border: 2px dashed #79c0ff; border-radius: 10px;
    }

    .result-cell {
      background: #48bb78; color: white;
      animation: pulse 0.5s ease-in-out;
    }

    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }

    .pooling-demo {
      display: grid; grid-template-columns: 1fr auto 1fr;
      gap: 20px; align-items: center;
    }

    .pooling-window {
      border: 2px solid #ed8936; border-radius: 5px;
      padding: 10px; background: rgba(237, 137, 54, 0.1);
    }

    .neuron-network {
      display: flex; justify-content: space-between; align-items: center;
      margin: 30px 0;
    }

    .layer {
      display: flex; flex-direction: column; gap: 10px;
    }

    .neuron {
      width: 30px; height: 30px; background: #4a5568;
      border-radius: 50%; display: flex; align-items: center; justify-content: center;
      font-size: 10px; color: white; transition: all 0.3s ease;
    }

    .neuron.active { background: #48bb78; transform: scale(1.2); }
    .neuron.processing { background: #f56565; animation: blink 0.5s infinite; }

    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0.5; }
    }

    .bce-calculator {
      background: #1a1a1a; padding: 20px; border-radius: 10px;
      border: 1px solid #333; margin: 20px 0;
    }

    .input-group {
      margin: 10px 0;
    }

    .input-group label {
      display: block; margin-bottom: 5px; font-weight: bold;
    }

    .input-group input {
      width: 100px; padding: 5px; border: 1px solid #555;
      border-radius: 3px; background: #2d3748; color: white;
      font-size: 14px;
    }

    .bce-result {
      font-size: 24px; color: #48bb78; text-align: center;
      margin: 20px 0; padding: 15px; background: #2d3748; border-radius: 5px;
    }

    .signal-canvas {
      background: #1a1a1a; border-radius: 5px; padding: 10px;
      border: 1px solid #333;
    }

    .spectrogram-canvas {
      background: #000; border-radius: 5px; padding: 10px;
      border: 1px solid #333;
    }

    .architecture-demo {
      margin: 30px 0;
    }

    .layer-visualization {
      display: flex; align-items: center; justify-content: center;
      margin: 20px 0; position: relative;
    }

    .layer-box {
      background: #2d3748; border: 2px solid #4a5568;
      border-radius: 8px; padding: 15px; margin: 0 10px;
      text-align: center; min-width: 120px;
      transition: all 0.3s ease;
    }

    .layer-box.active { border-color: #48bb78; background: #2f4f2f; }
    .layer-box.processing { border-color: #f56565; background: #4f2f2f; }

    .dimension-indicator {
      font-size: 12px; color: #79c0ff; margin-top: 5px;
    }

    .step-indicator {
      font-size: 16px; color: #ed8936; text-align: center; margin: 20px 0;
      padding: 10px; background: #2d3748; border-radius: 5px;
    }

    .interactive-controls {
      text-align: center; margin: 20px 0;
    }

    .btn {
      background: #4a5568; color: white; border: none;
      padding: 10px 20px; border-radius: 5px; margin: 0 5px;
      cursor: pointer; transition: all 0.3s ease;
    }

    .btn:hover { background: #5a6578; }
    .btn.play { background: #48bb78; }
    .btn.pause { background: #f56565; }
    .btn.reset { background: #ed8936; }

    .animation-legend {
      font-size: 12px; color: #9da7b3; text-align: center; margin: 10px 0;
    }

    /* Gradient Descent Styles */
    .optimizer-container {
      position: relative;
      width: 100%;
      height: 400px;
      margin: 20px 0;
    }

    .surface-canvas {
      width: 100%;
      height: 100%;
      border: 1px solid #333;
      border-radius: 8px;
      background: #1a1a1a;
    }

    .ball {
      position: absolute;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      transition: all 0.1s ease;
      z-index: 10;
    }

    .ball.gd { background: #f56565; box-shadow: 0 0 10px #f56565; }
    .ball.adam { background: #48bb78; box-shadow: 0 0 10px #48bb78; }

    .stats-panel {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin: 20px 0;
    }

    .stat-box {
      background: #2d3748;
      padding: 15px;
      border-radius: 8px;
      border: 2px solid #4a5568;
    }

    .stat-box h4 {
      margin: 0 0 10px 0;
      color: #79c0ff;
    }

    .stat-value {
      font-size: 20px;
      font-weight: bold;
      color: #48bb78;
    }

    .diagram-container {
      background: #1a1a1a;
      padding: 20px;
      border-radius: 8px;
      margin: 20px 0;
      border: 1px solid #333;
    }

    .network-diagram {
      display: flex;
      justify-content: space-around;
      align-items: center;
      min-height: 300px;
    }

    .network-layer {
      display: flex;
      flex-direction: column;
      gap: 15px;
      align-items: center;
    }

    .network-node {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: #4a5568;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
      transition: all 0.3s ease;
      border: 2px solid #6a7588;
    }

    .network-node.active {
      background: #48bb78;
      border-color: #48bb78;
      transform: scale(1.2);
    }

    .connection-line {
      stroke: #79c0ff;
      stroke-width: 2;
      opacity: 0.3;
      transition: all 0.3s ease;
    }

    .connection-line.active {
      stroke: #48bb78;
      stroke-width: 3;
      opacity: 1;
    }

    .three-col {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 20px;
      align-items: start;
    }
  </style>
</head>
<body>
  <div class="reveal">
    <div class="slides">

      <!-- ===== CAPA ===== -->
      <section>
        <h1>Monitoramento Inteligente da Dressagem de Rebolos</h1>
        <h2>Com Emissão Acústica (EA), STFT e CNN</h2>
        <p><strong>Orientador:</strong> Dr. Wenderson Nascimento Lopes</p>
        <p class="small"><strong>Discente:</strong> Ronald José Contijo<br/>
        <strong>Curso:</strong> Engenharia de Controle e Automação - IFPR<br/>
        <strong>Apresentação:</strong> 21/08/2025, 16:20</p>
        <p class="badge">Projeto de TCC I</p>
      </section>

      <!-- ===== 1. TEMA ===== -->
      <section>
        <h2>1. Tema</h2>
        <ul>   
          <li>Classificação do estado do rebolo (<em>undressed/dressed</em>) durante a dressagem</li>
          <li>Processamento de sinais de <strong>Emissão Acústica</strong> via análise tempo-frequência (STFT)</li>
          <li>Aplicação de <strong>Redes Neurais Convolucionais (CNN)</strong> para classificação automática</li>
          <li>Apoio à decisão do operador baseado em dados científicos</li>
        </ul>
        <div style="display: flex; gap: 20px; justify-content: center; margin-top: 20px;">
          <img src="rebolo.jpg" style="width: 45%; height: auto; border: 2px solid #333; border-radius: 5px;">
          <img src="conv.png" style="width: 45%; height: auto; border: 2px solid #333; border-radius: 5px;">
        </div>
      </section>

      <!-- ===== 2. PROBLEMA E JUSTIFICATIVA ===== -->
      <section>
        <h2>2. Problema e Justificativa</h2>
        <div class="two-col">
          <div>
            <h3>Problema</h3>
            <ul>
              <li>Momento ideal para interromper a dressagem depende da experiência do operador</li>
              <li>Dependência subjetiva gera inconsistências e aumento de custos</li>
              <li>Decisões inadequadas: dressagem precoce ou prolongada</li>
              <li>Impacto direto na qualidade da retificação</li>
            </ul>
          </div>
          <div>
            <h3>Justificativa</h3>
            <ul>
              <li>Aplicação dos princípios de Taylor (1911) para padronização</li>
              <li>Substituição de métodos empíricos por dados científicos</li>
              <li>Crescente demanda por soluções automatizadas na indústria</li>
              <li>Redução de custos e melhoria da qualidade</li>
            </ul>
          </div>
        </div>
      </section>

      <!-- ===== 3. OBJETIVOS ===== -->
      <section>
        <h2>3. Objetivos</h2>
        <div class="methodology-step">
          <h3>Objetivo Geral</h3>
          <p>Desenvolver metodologia baseada em IA para classificar o estado de rebolos convencionais durante dressagem, auxiliar operador na decisão "dressed" vs "undressed"</p>
        </div>
        <div class="methodology-step">
          <h3>Objetivos Específicos</h3>
          <ul>
            <li>Realizar ensaios de dressagem e coletar sinais de EA</li>
            <li>Gerar espectrogramas via STFT com parâmetros otimizados</li>
            <li>Treinar/validar CNN com imagens RGB dos espectrogramas</li>
            <li>Avaliar acurácia e função de perda BCE</li>
          </ul>
        </div>
      </section>

      <!-- ===== 4. FUNDAMENTAÇÃO TEÓRICA ===== -->
      
      <!-- Fundamentação - Dressagem -->
      <section>
        <h2>4. Fundamentação Teórica - Dressagem</h2>
        <div class="highlight-box">
          <p><strong>Definição:</strong> A dressagem é uma operação fundamental que recondiciona a superfície ativa do rebolo, restaurando sua geometria e afiando os grãos abrasivos.</p>
        </div>
        <ul>
          <li><strong>Parâmetros principais:</strong>
            <ul>
              <li>Largura de atuação do dressador (bd)</li>
              <li>Passo de dressagem (Sd)</li>
              <li>Tempo de dressagem (td)</li>
              <li>Grau de recobrimento (Ud)</li>
            </ul>
          </li>
          <li><strong>Equipamento:</strong> Dressador diamante de ponta única (CVD)</li>
          <li><strong>Retificadora:</strong> RAPH 1055 da Sulmecânica</li>
          <li><strong>Rebolos:</strong> Óxido de alumínio (NORTON)</li>
        </ul>
      </section>

      <!-- Fundamentação - Emissão Acústica -->
      <section>
        <h2>4. Fundamentação Teórica - Emissão Acústica</h2>
        <div class="two-col">
          <div>
            <h3>Mecanismo</h3>
            <ul>
              <li>Vibrações mecânicas do contato dressador-rebolo geram sinais informativos</li>
              <li>Conversão em sinais elétricos via sensores piezoelétricos</li>
              <li>Coleta a 2MHz usando osciloscópio DL850 da Yokogawa</li>
            </ul>
          </div>
          <div>
            <h3>Aplicação</h3>
            <ul>
              <li>Análise de sinais permite monitorar o estado do rebolo</li>
              <li>Características distintas para diferentes condições</li>
              <li>Base para classificação automática</li>
            </ul>
          </div>
        </div>
        <div class="highlight-box">
          <p><strong>Descobertas experimentais:</strong></p>
          <ul>
            <li><strong>Undressed:</strong> Níveis irregulares de amplitude</li>
            <li><strong>Dressed:</strong> Níveis uniformes de amplitude</li>
          </ul>
        </div>
      </section>

      <!-- Fundamentação - STFT com Animação -->
      <section>
        <h2>4. Fundamentação - STFT (Análise Visual)</h2>
        <p>A <strong>STFT</strong> analisa sinais não estacionários onde amplitude, frequência e fase variam no tempo</p>
        <div class="animation-container">
          <div class="interactive-controls">
            <button class="btn play" onclick="startSTFTAnalysis()">▶ Gera Sinal</button>
            <button class="btn reset" onclick="resetSTFTAnalysis()">⟲ Reset</button>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
            <div class="signal-canvas" style="width: 100%;">
              <h4 style="text-align: center;">Sinal Original</h4>
              <canvas id="timeSignal" width="550" height="280" style="width: 100%; height: auto;"></canvas>
            </div>
            <div class="spectrogram-canvas" style="width: 100%;">
              <h4 style="text-align: center;">Espectrograma STFT</h4>
              <canvas id="spectrogram" width="550" height="280" style="width: 100%; height: auto;"></canvas>
            </div>
          </div>
          <p class="animation-legend">5 tipos de sinais diferentes são gerados aleatoriamente: Chirp | Pulsos | Multifrequência | Modulação AM | Burst</p>
        </div>
      </section>

      <!-- Fundamentação - Redes Neurais -->
      <section>
        <h2>4. Fundamentação - Redes Neurais Artificiais</h2>
        <div class="two-col">
          <div>
            <h3>RNA e Deep Learning</h3>
            <ul>
              <li><strong>RNA:</strong> modelo inspirado no cérebro humano</li>
              <li><strong>Deep Learning:</strong> 3+ camadas de neurônios</li>
              <li>Capacidade de aprender representações hierárquicas</li>
              <li>Treinamento por backpropagation</li>
            </ul>
          </div>
          <div>
            <h3>CNNs</h3>
            <ul>
              <li>Especializadas em processamento de imagens</li>
              <li><strong>Convolução:</strong> extrai características locais</li>
              <li><strong>Pooling:</strong> reduz dimensionalidade</li>
              <li>Ideal para classificação de espectrogramas</li>
            </ul>
          </div>
        </div>
        <div class="highlight-box">
          <p><strong>Vantagens das CNNs:</strong> Capturam relações complexas entre diferentes partes das imagens, ideais para padrões tempo-frequência</p>
        </div>
      </section>

      <!-- Fundamentação - Elementos Constituintes do Algoritmo -->
      <section>
        <h2>4. Fundamentação - Elementos Constituintes do Algoritmo</h2>
        <table style="width:100%; border-collapse: collapse; font-size: 0.8em;">
          <tr style="background: #1a1a1a;">
            <th style="border: 1px solid #555; padding: 8px;">Elemento</th>
            <th style="border: 1px solid #555; padding: 8px;">Descrição</th>
          </tr>
          <tr>
            <td style="border: 1px solid #555; padding: 8px;">Função de Ativação</td>
            <td style="border: 1px solid #555; padding: 8px;">ReLU (Rectified Linear Unit): Introduz não-linearidade, eficiente computacionalmente, evita vanishing gradient.</td>
          </tr>
          <tr>
            <td style="border: 1px solid #555; padding: 8px;">Função de Perda</td>
            <td style="border: 1px solid #555; padding: 8px;">Binary Cross Entropy (BCE): Mede a diferença entre previsões e rótulos binários, ideal para classificação binária.</td>
          </tr>
          <tr>
            <td style="border: 1px solid #555; padding: 8px;">Otimizador</td>
            <td style="border: 1px solid #555; padding: 8px;">Adam: Combina momento adaptativo e taxa de aprendizado ajustável, converge mais rápido e estável.</td>
          </tr>
          <tr>
            <td style="border: 1px solid #555; padding: 8px;">Pooling</td>
            <td style="border: 1px solid #555; padding: 8px;">Max Pooling: Reduz dimensionalidade mantendo características importantes, evita overfitting.</td>
          </tr>
          <tr>
            <td style="border: 1px solid #555; padding: 8px;">Camadas Convolucionais</td>
            <td style="border: 1px solid #555; padding: 8px;">Extraem características locais das imagens, como bordas e padrões nos espectrogramas.</td>
          </tr>
        </table>
      </section>

      <!-- Fundamentação - Diagrama de Rede Neural -->
      <section>
        <h2>4. Fundamentação - Arquitetura de Rede Neural</h2>
        <div class="diagram-container">
          <img src="cnn.png" class="slide-image" alt="Arquitetura CNN">
        </div>
        <div class="methodology-step">
          <p><strong>Processamento:</strong> Entrada → Camadas Ocultas (extração de características) → Saída (classificação)</p>
        </div>
      </section>

      <!-- Fundamentação - Convolução Visual -->
      <section>
        <h2>4. Fundamentação - Operação de Convolução</h2>
        <div class="animation-container">
          <div class="convolution-demo">
            <div>
              <h4>Imagem de Entrada (5×5)</h4>
              <div class="matrix matrix-5x5" id="inputMatrix"></div>
            </div>
            
            <div>
              <div class="convolution-filter">
                ×<br>Filtro 3×3
              </div>
            </div>
            
            <div>
              <h4>Feature Map (3×3)</h4>
              <div class="matrix matrix-3x3" id="outputMatrix"></div>
            </div>
          </div>
          <div class="interactive-controls">
            <button class="btn play" onclick="startConvolution()">▶ Convolução</button>
            <button class="btn reset" onclick="resetConvolution()">⟲ Reset</button>
          </div>
          <div class="animation-legend">
            ✨ Vermelho: célula sendo processada | Verde: resultado da operação
          </div>
        </div>
        <p class="small"><strong>Convolução:</strong> Aplica um filtro que desliza sobre a imagem, extraindo características como bordas, texturas e padrões</p>
      </section>

      <!-- Fundamentação - Pooling Visual -->
      <section>
        <h2>4. Fundamentação - Operação de Pooling</h2>
        <div class="animation-container">
          <div class="pooling-demo">
            <div>
              <h4>Feature Map (4×4)</h4>
              <div class="matrix matrix-4x4" id="poolingInput"></div>
            </div>
            
            <div>
              <div class="pooling-window">
                <strong>Max Pooling 2×2</strong><br>
                <small>Janela deslizante</small><br>
                <small>Seleciona o valor máximo</small>
              </div>
            </div>
            
            <div>
              <h4>Resultado (2×2)</h4>
              <div class="matrix matrix-2x2" id="poolingOutput"></div>
            </div>
          </div>
          <div class="interactive-controls">
            <button class="btn play" onclick="startPooling()">▶ Pooling</button>
            <button class="btn reset" onclick="resetPooling()">⟲ Reset</button>
          </div>
        </div>
        <p class="small"><strong>Pooling:</strong> Reduz dimensionalidade mantendo características importantes, evita overfitting</p>
      </section>

      <!-- Fundamentação - Função de Ativação ReLU -->
      <section>
        <h2>4. Fundamentação - Função de Ativação ReLU</h2>
        <div class="animation-container">
          <canvas id="reluCanvas" width="600" height="300" style="display: block; margin: 0 auto;"></canvas>
        </div>
        <div class="equation" style="text-align: center;">
          ReLU(x) = max(0, x)
        </div>
        <div class="two-col">
          <div>
            <h4>Características</h4>
            <ul>
              <li>Não linear</li>
              <li>Computacionalmente eficiente</li>
              <li>Evita vanishing gradient</li>
            </ul>
          </div>
          <div>
            <h4>Aplicação</h4>
            <ul>
              <li>Introduz não-linearidade</li>
              <li>Zero para valores negativos</li>
              <li>Linear para valores positivos</li>
            </ul>
          </div>
        </div>
      </section>

      <!-- Fundamentação - Gradiente Descendente -->
      <section>
        <h2>4. Fundamentação - Gradiente Descendente (GD)</h2>
        <div style="text-align: center; margin: 30px 0;">
          <img src="gradiente.gif" alt="Animação Gradiente Descendente" style="max-width: 80%; height: auto; border: 2px solid #333; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.3);">
        </div>

      </section>

      <!-- Fundamentação - Binary Cross Entropy -->
      <section>
        <h2>4. Fundamentação - Função de Perda BCE</h2>
        <div class="equation">
          BCE = -(1/N) Σ[i=1 a N][yᵢlog(pᵢ) + (1-yᵢ)log(1-pᵢ)]
        </div>
        <div class="highlight-box">
           <h3>Exemplo de Cálculo</h3>
           <p><strong>Previsão correta (y=1, p=0.9):</strong> BCE = -log(0.9) ≈ 0.105</p>
           <p><strong>Previsão incorreta (y=0, p=0.8):</strong> BCE = -log(1-0.8) ≈ 1.609</p>
         </div>
      </section>
 <!-- Fundamentação - Conversão Imagem para Números -->
 <section>
  <h2>4. Fundamentação - Conversão Imagem para Números</h2>
  <div class="diagram-container">
    <img src="rgb.webp" style="width: 50%; height: auto; border: 2px solid #333; border-radius: 5px; box-shadow: 0 4px 8px rgba(0,0,0,0.3);" alt="Conversão Imagem RGB para Matriz Numérica">

</section>

<!-- Fundamentação - Operação de Flattening -->
<section>
  <h2>4. Fundamentação - Operação de Flattening</h2>
  <div class="diagram-container">
    <img src="flattening.webp" style="width: 50%; height: auto; border: 2px solid #333; border-radius: 5px; box-shadow: 0 4px 8px rgba(0,0,0,0.3);" alt="Conversão Imagem RGB para Matriz Numérica">

  </div>
</section>
      <!-- ===== 5. METODOLOGIA ===== -->
      
      <!-- Metodologia - Materiais -->
      <section>
        <h2>5. Metodologia - Materiais e Equipamentos</h2>
        <div class="two-col">
          <div>
            <h3>Rebolos</h3>
            <ul>
              <li><strong>Rebolo A:</strong> 38A.100.LVH (355,6×25,4×127 mm)</li>
              <li><strong>Rebolo B:</strong> 38A.150.LVH (324×25,4×127 mm)</li>
              <li>Material: óxido de alumínio (NORTON)</li>
            </ul>
            <h3>Dressador</h3>
            <ul>
              <li>Diamante de ponta única</li>
              <li>Fabricação: CVD</li>
            </ul>
          </div>
          <div>
            <h3>Equipamentos</h3>
            <ul>
              <li><strong>Retificadora:</strong> RAPH 1055 (Sulmecânica)</li>
              <li><strong>Osciloscópio:</strong> DL850 (Yokogawa)</li>
              <li><strong>Microscópio:</strong> USB DNT DigiMicro 2.0</li>
              <li><strong>Freq. amostragem:</strong> 2 MHz</li>
            </ul>
          </div>
        </div>
      </section>

      <!-- Metodologia - Processamento STFT -->
      <section>
        <h2>5. Metodologia - Processamento STFT</h2>
        <div class="methodology-step">
          <h3>Configuração dos Parâmetros</h3>
          <ul>
            <li><strong>Janela:</strong> Hanning com 4096 pontos</li>
            <li><strong>Sobreposição:</strong> 75% das janelas</li>
            <li><strong>FFT:</strong> 8192 pontos para Transformada Discreta de Fourier</li>
            <li><strong>Resolução temporal:</strong> ~2 milissegundos</li>
            <li><strong>Resolução frequencial:</strong> 488 Hz</li>
            <li><strong>Faixa de frequência:</strong> 0-500 kHz</li>
          </ul>
        </div>
        <p><strong>Resultado:</strong> Espectrogramas com ~180×180×3 pixels (RGB) para entrada na CNN</p>
      </section>


     

      <!-- Metodologia - Treinamento -->
      <section>
        <h2>5. Metodologia - Processo de Treinamento</h2>
        <div class="methodology-step">
          <h3>Pré-processamento</h3>
          <ul>
            <li>Extração dos dados do passe de dressagem dos sinais originais</li>
            <li>Geração de espectrogramas via STFT com parâmetros otimizados</li>
            <li>Normalização RGB das imagens para 180×180×3 pixels</li>
            <li>Rotulagem binária: "undressed" (0) vs "dressed" (1)</li>
          </ul>
        </div>
        <div class="methodology-step">
          <h3>Treinamento e Validação</h3>
          <ul>
            <li><strong>Divisão de dados:</strong> treinamento, validação e teste</li>
            <li><strong>Função de perda:</strong> Binary Cross Entropy (BCE)</li>
            <li><strong>Otimizador:</strong> Adam (learning rate adaptativo)</li>
            <li><strong>Métrica principal:</strong> acurácia</li>
            <li><strong>Ferramentas:</strong> Python, TensorFlow/Keras, Jupyter Notebook</li>
          </ul>
        </div>
      </section>



      <!-- ===== 6. RESULTADOS ESPERADOS ===== -->
      
      <!-- Resultados -->
      <section>
        <h2>6. Resultados</h2>
        <div class="methodology-step">
          <h3>Classificador</h3>
          <ul>
            <li>Alta acurácia na classificação "undressed" vs "dressed"</li>
            <li>Redução da dependência da experiência do operador</li>
            <li>Sistema capaz de ser empacotado em software</li>
            <li>Execução feita com TensorFlow Lite, e exportação ONNX</li>
          </ul>
        </div>

      </section>
      <section>
        <h2>6. Resultados - Função de Perda</h2>
        <img src="perda.png" style="width: 70%; margin: 20px auto; display: block; border: 2px solid #333; border-radius: 5px;" alt="Gráfico da Função de Perda">
      </section>

      <section>
        <h2>6. Resultados - Acurácia</h2>
        <img src="acuracia.png" style="width: 70%; margin: 20px auto; display: block; border: 2px solid #333; border-radius: 5px;" alt="Gráfico de Acurácia">
      </section>


      <section>
        <h2>7. Considerações Finais</h2>
        <ul>
          <li><strong>Contribuição Científica:</strong> Proposta inovadora combinando processamento de sinais com inteligência artificial para otimizar operação crítica de dressagem</li>
          <li><strong>Impacto Possível:</strong>
            <ul>
              <li>Redução da dependência da experiência subjetiva do operador</li>
              <li>Contribuição para monitoramento de processos de manufatura</li>
              <li>Auxílio aos operadores industriais para uso eficiente dos rebolos</li>
            </ul>
          </li>
          <li><strong>Trabalhos Futuros:</strong>
            <ul>
              <li>Treinar a rede com mais dados</li>
              <li>Comparação CNN vs LSTM com dados multivariados</li>
              <li>Integração com sistemas de controle de qualidade</li>
            </ul>
          </li>
        </ul>
      </section>


      <section>
        <h2>Cronograma de Atividades</h2>
        <table style="width:100%; border-collapse: collapse; font-size: 0.7em;">
          <tr style="background: #1a1a1a;">
            <th style="border: 1px solid #555; padding: 8px;">Atividade</th>
            <th style="border: 1px solid #555; padding: 8px;">1º Bim</th>
            <th style="border: 1px solid #555; padding: 8px;">2º Bim</th>
            <th style="border: 1px solid #555; padding: 8px;">3º Bim</th>
            <th style="border: 1px solid #555; padding: 8px;">4º Bim</th>
            <th style="border: 1px solid #555; padding: 8px;">5º Bim</th>
            <th style="border: 1px solid #555; padding: 8px;">6º Bim</th>
          </tr>
          <tr>
            <td style="border: 1px solid #555; padding: 8px;">Revisão Bibliográfica</td>
            <td style="background: #4a5568; border: 1px solid #555; padding: 8px;">■■■</td>
            <td style="border: 1px solid #555; padding: 8px;"></td>
            <td style="border: 1px solid #555; padding: 8px;"></td>
            <td style="border: 1px solid #555; padding: 8px;"></td>
            <td style="border: 1px solid #555; padding: 8px;"></td>
            <td style="border: 1px solid #555; padding: 8px;"></td>
          </tr>
          <tr>
            <td style="border: 1px solid #555; padding: 8px;">Entrega do Projeto</td>
            <td style="border: 1px solid #555; padding: 8px;"></td>
            <td style="background: #4a5568; border: 1px solid #555; padding: 8px;">■■■</td>
            <td style="border: 1px solid #555; padding: 8px;"></td>
            <td style="border: 1px solid #555; padding: 8px;"></td>
            <td style="border: 1px solid #555; padding: 8px;"></td>
            <td style="border: 1px solid #555; padding: 8px;"></td>
          </tr>
          <tr>
            <td style="border: 1px solid #555; padding: 8px;">Estudo TensorFlow/Keras</td>
            <td style="border: 1px solid #555; padding: 8px;"></td>
            <td style="border: 1px solid #555; padding: 8px;"></td>
            <td style="background: #4a5568; border: 1px solid #555; padding: 8px;">■■■</td>
            <td style="border: 1px solid #555; padding: 8px;"></td>
            <td style="border: 1px solid #555; padding: 8px;"></td>
            <td style="border: 1px solid #555; padding: 8px;"></td>
          </tr>
          <tr>
            <td style="border: 1px solid #555; padding: 8px;">Implementação CNN</td>
            <td style="border: 1px solid #555; padding: 8px;"></td>
            <td style="border: 1px solid #555; padding: 8px;"></td>
            <td style="border: 1px solid #555; padding: 8px;"></td>
            <td style="background: #4a5568; border: 1px solid #555; padding: 8px;">■■■</td>
            <td style="border: 1px solid #555; padding: 8px;"></td>
            <td style="border: 1px solid #555; padding: 8px;"></td>
          </tr>
          <tr>
            <td style="border: 1px solid #555; padding: 8px;">Avaliação da Rede</td>
            <td style="border: 1px solid #555; padding: 8px;"></td>
            <td style="border: 1px solid #555; padding: 8px;"></td>
            <td style="border: 1px solid #555; padding: 8px;"></td>
            <td style="border: 1px solid #555; padding: 8px;"></td>
            <td style="background: #4a5568; border: 1px solid #555; padding: 8px;">■■■</td>
            <td style="border: 1px solid #555; padding: 8px;"></td>
          </tr>
          <tr>
            <td style="border: 1px solid #555; padding: 8px;">Entrega do TCC</td>
            <td style="border: 1px solid #555; padding: 8px;"></td>
            <td style="border: 1px solid #555; padding: 8px;"></td>
            <td style="border: 1px solid #555; padding: 8px;"></td>
            <td style="border: 1px solid #555; padding: 8px;"></td>
            <td style="border: 1px solid #555; padding: 8px;"></td>
            <td style="background: #4a5568; border: 1px solid #555; padding: 8px;">■■■</td>
          </tr>
        </table>
      </section>

      <!-- Referências 1 -->
      <section>
        <h2>Referências Bibliográficas (1/2)</h2>
        <div class="reference">
          <p><strong>CHOLLET, François.</strong> Deep learning with Python. 2. ed. [S.l.]: Manning, 2021.</p>
        </div>
        <div class="reference">
          <p><strong>GARRIDO, Mario.</strong> The feedforward short-time Fourier transform. <em>IEEE Transactions on Circuits and Systems II: Express Briefs</em>, v. 63, n. 9, p. 868–872, 2016.</p>
        </div>
        <div class="reference">
          <p><strong>GONG, X. et al.</strong> Application of deep learning in defect detection. <em>Journal of Physics: Conference Series</em>, v. 1684, 012030, 2020.</p>
        </div>
        <div class="reference">
          <p><strong>INDOLIA, Sakshi et al.</strong> Conceptual understanding of convolutional neural network: a deep learning approach. <em>Procedia Computer Science</em>, v. 132, p. 679–688, 2018.</p>
        </div>
        <div class="reference">
          <p><strong>MARINESCU, Ioan D. et al.</strong> Handbook of machining with grinding wheels. 2. ed. Boca Raton: CRC Press, 2016.</p>
        </div>
        <div class="reference">
          <p><strong>MSSQLTIPS.</strong> Convolutional Neural Networks for Machine Learning. Disponível em: <a href="https://www.mssqltips.com/sqlservertip/11473/convolutional-neural-networks-for-machine-learning/">https://www.mssqltips.com/sqlservertip/11473/convolutional-neural-networks-for-machine-learning/</a>.</p>
        </div>
      </section>

      <!-- Referências 2 -->
      <section>
        <h2>Referências Bibliográficas (2/2)</h2>
        <div class="reference">
          <p><strong>RUBY, Usha; YENDAPALLI, Vamsidhar.</strong> Binary cross entropy with deep learning technique for image classification. <em>International Journal of Advanced Trends in Computer Science and Engineering</em>, v. 9, n. 10, 2020.</p>
        </div>
        <div class="reference">
          <p><strong>RUSSELL, Stuart J.; NORVIG, Peter.</strong> Artificial intelligence: a modern approach. 3. ed. Harlow: Pearson Education, 2016.</p>
        </div>
        <div class="reference">
          <p><strong>TAYLOR, Frederick Winslow.</strong> The principles of scientific management. New York: Harper & Brothers, 1911.</p>
        </div>
        <div class="reference">
          <p><strong>SHUKLA, Lavanya.</strong> Gradient Descent vs Adagrad vs Momentum in TensorFlow. <em>Wandb Reports</em>, 2021. Disponível em: <a href="https://wandb.ai/lavanyashukla/visualize-models/reports/Gradient-Descent-vs-Adagrad-vs-Momentum-in-TensorFlow--VmlldzoxOTg2MjM">https://wandb.ai/lavanyashukla/visualize-models/reports/Gradient-Descent-vs-Adagrad-vs-Momentum-in-TensorFlow--VmlldzoxOTg2MjM</a>.</p>
        </div>

      </section>




    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/dist/reveal.js"></script>
  
  <!-- Animation JavaScript -->
  <script>
    // Global variables for animations
    let convolutionAnimationRunning = false;
    let poolingAnimationRunning = false;
    let architectureAnimationRunning = false;
    let gdAnimationRunning = false;
    let adamAnimationRunning = false;
    let comparisonAnimationRunning = false;

    // Initialize Reveal.js
    Reveal.initialize({
      hash:true,
      slideNumber:true,
      progress:true,
      controls:true,
      center:false,
      width:1280,
      height:720,
      margin:0.06
    });

    // Re-initialize canvases when slides change
    Reveal.on('slidechanged', event => {
      // Check if we're on a gradient descent slide
      if (event.currentSlide.querySelector('#gdCanvas')) {
        setTimeout(initializeGDCanvas, 100);
      }
      if (event.currentSlide.querySelector('#adamCanvas')) {
        setTimeout(initializeAdamCanvas, 100);
      }
      if (event.currentSlide.querySelector('#comparisonCanvas')) {
        setTimeout(initializeComparisonCanvas, 100);
      }
    });

    // ===== INITIALIZATION =====
    document.addEventListener('DOMContentLoaded', function() {
      initializeConvolutionDemo();
      initializePoolingDemo();
      resetSTFTAnalysis();
      initializeNetworkDiagram();
      initializeFlowchart();
      
      // Initialize gradient descent visualizations
      initializeGDCanvas();
      initializeAdamCanvas();
      initializeComparisonCanvas();
      
      // BCE calculator event listeners
      ['y1', 'p1', 'y2', 'p2', 'N'].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.addEventListener('change', calculateBCE);
      });
      
      calculateBCE();
      drawReLUGraph();
    });

    // ===== INITIALIZE OPTIMIZER CANVASES =====
    function initializeGDCanvas() {
      const canvas = document.getElementById('gdCanvas');
      const ball = document.getElementById('gdBall');
      if (!canvas || !ball) return;
      
      const ctx = canvas.getContext('2d');
      drawLossLandscape(ctx, canvas.width, canvas.height);
      
      ball.style.left = (canvas.width * 0.2) + 'px';
      ball.style.top = (canvas.height * 0.2) + 'px';
    }

    function initializeAdamCanvas() {
      const canvas = document.getElementById('adamCanvas');
      const ball = document.getElementById('adamBall');
      if (!canvas || !ball) return;
      
      const ctx = canvas.getContext('2d');
      drawLossLandscape(ctx, canvas.width, canvas.height);
      
      ball.style.left = (canvas.width * 0.2) + 'px';
      ball.style.top = (canvas.height * 0.2) + 'px';
    }

    function initializeComparisonCanvas() {
      const canvas = document.getElementById('comparisonCanvas');
      const gdBall = document.getElementById('compGdBall');
      const adamBall = document.getElementById('compAdamBall');
      if (!canvas || !gdBall || !adamBall) return;
      
      const ctx = canvas.getContext('2d');
      drawLossLandscape(ctx, canvas.width, canvas.height);
      
      gdBall.style.left = (canvas.width * 0.2) + 'px';
      gdBall.style.top = (canvas.height * 0.2) + 'px';
      adamBall.style.left = (canvas.width * 0.2) + 'px';
      adamBall.style.top = (canvas.height * 0.2) + 'px';
    }

    // ===== CONVOLUTION ANIMATION =====
    function initializeConvolutionDemo() {
      const inputMatrix = document.getElementById('inputMatrix');
      const outputMatrix = document.getElementById('outputMatrix');
      if (!inputMatrix || !outputMatrix) return;
      
      const inputData = [
        [1, 2, 3, 0, 1],
        [0, 1, 2, 3, 0],
        [3, 0, 1, 2, 1],
        [1, 3, 0, 1, 2],
        [2, 1, 3, 0, 1]
      ];
      
      inputMatrix.innerHTML = '';
      for (let i = 0; i < 5; i++) {
        for (let j = 0; j < 5; j++) {
          const cell = document.createElement('div');
          cell.className = 'matrix-cell';
          cell.textContent = inputData[i][j];
          cell.dataset.row = i;
          cell.dataset.col = j;
          inputMatrix.appendChild(cell);
        }
      }
      
      outputMatrix.innerHTML = '';
      for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 3; j++) {
          const cell = document.createElement('div');
          cell.className = 'matrix-cell';
          cell.textContent = '?';
          cell.dataset.outRow = i;
          cell.dataset.outCol = j;
          outputMatrix.appendChild(cell);
        }
      }
    }

    function startConvolution() {
      if (convolutionAnimationRunning) return;
      convolutionAnimationRunning = true;
      
      const inputCells = document.querySelectorAll('#inputMatrix .matrix-cell');
      const outputCells = document.querySelectorAll('#outputMatrix .matrix-cell');
      
      inputCells.forEach(cell => cell.className = 'matrix-cell');
      outputCells.forEach(cell => {
        cell.textContent = '?';
        cell.className = 'matrix-cell';
      });
      
      const filter = [[1, 0, 1], [0, 1, 0], [1, 0, 1]];
      let currentStep = 0;
      
      const animateStep = () => {
        if (currentStep >= 9 || !convolutionAnimationRunning) {
          convolutionAnimationRunning = false;
          return;
        }
        
        const outRow = Math.floor(currentStep / 3);
        const outCol = currentStep % 3;
        
        inputCells.forEach(cell => cell.className = 'matrix-cell');
        for (let i = 0; i < 3; i++) {
          for (let j = 0; j < 3; j++) {
            const inputRow = outRow + i;
            const inputCol = outCol + j;
            const cell = inputCells[inputRow * 5 + inputCol];
            cell.classList.add('active');
          }
        }
        
        let sum = 0;
        for (let i = 0; i < 3; i++) {
          for (let j = 0; j < 3; j++) {
            const inputValue = parseInt(inputCells[(outRow + i) * 5 + (outCol + j)].textContent);
            sum += inputValue * filter[i][j];
          }
        }
        
        const outputCell = outputCells[currentStep];
        outputCell.textContent = sum;
        outputCell.classList.add('result-cell');
        
        currentStep++;
        
        setTimeout(() => {
          inputCells.forEach(cell => cell.classList.remove('active'));
          outputCell.classList.remove('result-cell');
          outputCell.classList.add('highlight');
          setTimeout(animateStep, 500);
        }, 1000);
      };
      
      animateStep();
    }

    function resetConvolution() {
      convolutionAnimationRunning = false;
      initializeConvolutionDemo();
    }

    // ===== POOLING ANIMATION =====
    function initializePoolingDemo() {
      const poolingInput = document.getElementById('poolingInput');
      const poolingOutput = document.getElementById('poolingOutput');
      if (!poolingInput) return;
      
      const poolingData = [
        [4, 2, 1, 3],
        [6, 8, 3, 1],
        [2, 4, 7, 5],
        [1, 3, 2, 6]
      ];
      
      poolingInput.innerHTML = '';
      for (let i = 0; i < 4; i++) {
        for (let j = 0; j < 4; j++) {
          const cell = document.createElement('div');
          cell.className = 'matrix-cell';
          cell.textContent = poolingData[i][j];
          cell.dataset.row = i;
          cell.dataset.col = j;
          poolingInput.appendChild(cell);
        }
      }
      
      if (poolingOutput) {
        poolingOutput.innerHTML = '';
        for (let i = 0; i < 2; i++) {
          for (let j = 0; j < 2; j++) {
            const cell = document.createElement('div');
            cell.className = 'matrix-cell';
            cell.textContent = '?';
            poolingOutput.appendChild(cell);
          }
        }
      }
    }

    function startPooling() {
      if (poolingAnimationRunning) return;
      poolingAnimationRunning = true;
      
      const inputCells = document.querySelectorAll('#poolingInput .matrix-cell');
      const outputCells = document.querySelectorAll('#poolingOutput .matrix-cell');
      
      inputCells.forEach(cell => cell.className = 'matrix-cell');
      if (outputCells) outputCells.forEach(cell => cell.textContent = '?');
      
      let currentStep = 0;
      
      const animateStep = () => {
        if (currentStep >= 4 || !poolingAnimationRunning) {
          poolingAnimationRunning = false;
          return;
        }
        
        const outRow = Math.floor(currentStep / 2);
        const outCol = currentStep % 2;
        
        inputCells.forEach(cell => cell.className = 'matrix-cell');
        
        let max = -Infinity;
        const positions = [];
        for (let i = 0; i < 2; i++) {
          for (let j = 0; j < 2; j++) {
            const inputRow = outRow * 2 + i;
            const inputCol = outCol * 2 + j;
            const cell = inputCells[inputRow * 4 + inputCol];
            cell.classList.add('active');
            const value = parseInt(cell.textContent);
            if (value > max) max = value;
            positions.push(cell);
          }
        }
        
        positions.forEach(pos => {
          if (parseInt(pos.textContent) === max) {
            pos.classList.add('highlight');
          }
        });
        
        if (outputCells && outputCells[currentStep]) {
          outputCells[currentStep].textContent = max;
          outputCells[currentStep].classList.add('result-cell');
        }
        
        currentStep++;
        
        setTimeout(() => {
          inputCells.forEach(cell => {
            cell.classList.remove('active', 'highlight');
          });
          setTimeout(animateStep, 500);
        }, 1500);
      };
      
      animateStep();
    }

    function resetPooling() {
      poolingAnimationRunning = false;
      initializePoolingDemo();
    }

    // ===== STFT ANALYSIS =====
    function generateRandomSignal(length, sampleRate) {
      const signal = new Array(length);
      const dt = 1.0 / sampleRate;
      
      // Random signal type selector
      const signalType = Math.floor(Math.random() * 5);
      
      // Random parameters
      const freq1 = 50 + Math.random() * 100;   // 50-150 Hz
      const freq2 = 150 + Math.random() * 150;  // 150-300 Hz
      const freq3 = 300 + Math.random() * 200;  // 300-500 Hz
      const harmonicFreq = 100 + Math.random() * 200;
      const noiseLevel = 0.05 + Math.random() * 0.15;
      
      for (let i = 0; i < length; i++) {
        const t = i * dt;
        let value = 0;
        
        switch(signalType) {
          case 0: // Chirp - frequência crescente linear
            const fStart = 50;
            const fEnd = 500;
            const instantFreq = fStart + (fEnd - fStart) * t;
            value = Math.sin(2 * Math.PI * instantFreq * t / 2);
            break;
            
          case 1: // Pulsos de diferentes frequências
            if (t < 0.25) {
              value = Math.sin(2 * Math.PI * freq1 * t);
            } else if (t < 0.5) {
              value = Math.sin(2 * Math.PI * freq2 * t);
            } else if (t < 0.75) {
              value = Math.sin(2 * Math.PI * freq3 * t);
            } else {
              value = Math.sin(2 * Math.PI * harmonicFreq * t);
            }
            break;
            
          case 2: // Múltiplas frequências simultâneas
            value = Math.sin(2 * Math.PI * freq1 * t) * 0.5;
            value += Math.sin(2 * Math.PI * freq2 * t) * 0.3;
            value += Math.sin(2 * Math.PI * freq3 * t) * 0.2;
            break;
            
          case 3: // Modulação em amplitude
            const carrier = 200 + Math.random() * 200;
            const modulator = 10 + Math.random() * 20;
            value = (1 + 0.5 * Math.sin(2 * Math.PI * modulator * t)) *
                    Math.sin(2 * Math.PI * carrier * t);
            break;
            
          case 4: // Burst - pulsos com envelope
            const burstFreq = 150 + Math.random() * 150;
            const burstPeriod = 0.1 + Math.random() * 0.1;
            const envelope = Math.sin(2 * Math.PI * t / burstPeriod);
            if (envelope > 0) {
              value = envelope * Math.sin(2 * Math.PI * burstFreq * t);
            }
            break;
        }
        
        // Add random harmonic content
        value += (0.1 + Math.random() * 0.2) * Math.sin(2 * Math.PI * harmonicFreq * t);
        
        // Add noise
        value += noiseLevel * (Math.random() - 0.5);
        
        signal[i] = value;
      }
      
      return signal;
    }

    function computeSTFT(signal, windowSize, hopSize) {
      const numWindows = Math.floor((signal.length - windowSize) / hopSize) + 1;
      const fftSize = windowSize;
      const spectrogram = [];
      
      // Hanning window
      const window = new Array(windowSize);
      for (let i = 0; i < windowSize; i++) {
        window[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (windowSize - 1)));
      }
      
      for (let w = 0; w < numWindows; w++) {
        const start = w * hopSize;
        const windowed = new Array(windowSize);
        
        // Apply window
        for (let i = 0; i < windowSize; i++) {
          windowed[i] = signal[start + i] * window[i];
        }
        
        // Compute FFT (simplified using DFT for visualization)
        const spectrum = new Array(Math.floor(fftSize / 2));
        for (let k = 0; k < spectrum.length; k++) {
          let real = 0;
          let imag = 0;
          for (let n = 0; n < windowSize; n++) {
            const angle = -2 * Math.PI * k * n / fftSize;
            real += windowed[n] * Math.cos(angle);
            imag += windowed[n] * Math.sin(angle);
          }
          spectrum[k] = Math.sqrt(real * real + imag * imag) / windowSize;
        }
        
        spectrogram.push(spectrum);
      }
      
      return spectrogram;
    }

    function startSTFTAnalysis() {
      const timeCanvas = document.getElementById('timeSignal');
      const spectrogramCanvas = document.getElementById('spectrogram');
      if (!timeCanvas || !spectrogramCanvas) return;
      
      const timeCtx = timeCanvas.getContext('2d');
      const specCtx = spectrogramCanvas.getContext('2d');
      
      timeCtx.clearRect(0, 0, timeCanvas.width, timeCanvas.height);
      specCtx.clearRect(0, 0, spectrogramCanvas.width, spectrogramCanvas.height);
      
      // Generate signal
      const sampleRate = 2000; // Hz
      const duration = 1.0; // seconds
      const numSamples = sampleRate * duration;
      const signal = generateRandomSignal(numSamples, sampleRate);
      
      // Draw time domain signal
      timeCtx.strokeStyle = '#79c0ff';
      timeCtx.lineWidth = 2;
      timeCtx.beginPath();
      
      const downsample = Math.floor(signal.length / timeCanvas.width);
      for (let i = 0; i < timeCanvas.width; i++) {
        const idx = Math.min(i * downsample, signal.length - 1);
        const x = i;
        const y = timeCanvas.height / 2 - signal[idx] * timeCanvas.height / 4;
        if (i === 0) {
          timeCtx.moveTo(x, y);
        } else {
          timeCtx.lineTo(x, y);
        }
      }
      timeCtx.stroke();
      
      // Add grid
      timeCtx.strokeStyle = 'rgba(153, 167, 179, 0.2)';
      timeCtx.lineWidth = 1;
      for (let i = 0; i < 5; i++) {
        const y = (i / 4) * timeCanvas.height;
        timeCtx.beginPath();
        timeCtx.moveTo(0, y);
        timeCtx.lineTo(timeCanvas.width, y);
        timeCtx.stroke();
      }
      
      // Compute STFT
      const windowSize = 64;
      const hopSize = 16;
      const spectrogram = computeSTFT(signal, windowSize, hopSize);
      
      // Draw spectrogram - scale to fill entire canvas
      const maxMagnitude = Math.max(...spectrogram.flat());
      const canvasWidth = spectrogramCanvas.width;
      const canvasHeight = spectrogramCanvas.height;
      const timeScale = canvasWidth / spectrogram.length;
      const freqScale = canvasHeight / spectrogram[0].length;
      
      for (let t = 0; t < spectrogram.length; t++) {
        const spectrum = spectrogram[t];
        for (let f = 0; f < spectrum.length; f++) {
          const magnitude = spectrum[f];
          const intensity = Math.min(255, (magnitude / maxMagnitude) * 255);
          
          // Color mapping: black -> blue -> green -> yellow -> red
          let r, g, b;
          if (intensity < 64) {
            r = 0;
            g = 0;
            b = intensity * 4;
          } else if (intensity < 128) {
            r = 0;
            g = (intensity - 64) * 4;
            b = 255;
          } else if (intensity < 192) {
            r = (intensity - 128) * 4;
            g = 255;
            b = 255 - (intensity - 128) * 4;
          } else {
            r = 255;
            g = 255 - (intensity - 192) * 4;
            b = 0;
          }
          
          specCtx.fillStyle = `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;
          // Scale to fill entire canvas
          const x = Math.floor(t * timeScale);
          const y = Math.floor(canvasHeight - (f + 1) * freqScale);
          const w = Math.ceil(timeScale) + 1;
          const h = Math.ceil(freqScale) + 1;
          specCtx.fillRect(x, y, w, h);
        }
      }
      
      // Add frequency labels
      specCtx.fillStyle = '#e6edf3';
      specCtx.font = '12px sans-serif';
      specCtx.fillText('0 Hz', 5, canvasHeight - 5);
      specCtx.fillText('500 Hz', 5, 15);
      specCtx.fillText('Tempo →', canvasWidth - 55, canvasHeight - 5);
    }

    function resetSTFTAnalysis() {
      const timeCanvas = document.getElementById('timeSignal');
      const spectrogramCanvas = document.getElementById('spectrogram');
      if (!timeCanvas || !spectrogramCanvas) return;
      
      const timeCtx = timeCanvas.getContext('2d');
      const specCtx = spectrogramCanvas.getContext('2d');
      
      timeCtx.clearRect(0, 0, timeCanvas.width, timeCanvas.height);
      specCtx.fillStyle = '#000';
      specCtx.fillRect(0, 0, spectrogramCanvas.width, spectrogramCanvas.height);
      
      // Add labels to empty spectrogram
      specCtx.fillStyle = '#9da7b3';
      specCtx.font = '14px sans-serif';
      specCtx.fillText('Clique em "Analisar" para gerar STFT', 50, spectrogramCanvas.height / 2);
    }

    // ===== BCE CALCULATOR =====
    function calculateBCE() {
      const y1El = document.getElementById('y1');
      const p1El = document.getElementById('p1');
      const y2El = document.getElementById('y2');
      const p2El = document.getElementById('p2');
      const NEl = document.getElementById('N');
      
      if (!y1El || !p1El || !y2El || !p2El || !NEl) return;
      
      const y1 = parseFloat(y1El.value);
      const p1 = parseFloat(p1El.value);
      const y2 = parseFloat(y2El.value);
      const p2 = parseFloat(p2El.value);
      const N = parseInt(NEl.value);
      
      const contrib1 = -(y1 * Math.log(Math.max(p1, 1e-10)) + (1 - y1) * Math.log(Math.max(1 - p1, 1e-10)));
      const contrib2 = -(y2 * Math.log(Math.max(p2, 1e-10)) + (1 - y2) * Math.log(Math.max(1 - p2, 1e-10)));
      
      const contrib1El = document.getElementById('contribution1');
      const contrib2El = document.getElementById('contribution2');
      const finalResultEl = document.getElementById('finalResult');
      
      if (contrib1El) {
        contrib1El.textContent = contrib1.toFixed(3);
        contrib1El.style.color = contrib1 < 0.5 ? '#48bb78' : '#f56565';
      }
      if (contrib2El) {
        contrib2El.textContent = contrib2.toFixed(3);
        contrib2El.style.color = contrib2 < 0.5 ? '#48bb78' : '#f56565';
      }
      
      const bce = (contrib1 + contrib2) / N;
      if (finalResultEl) {
        finalResultEl.textContent = `BCE = ${bce.toFixed(3)}`;
        if (bce < 0.5) {
          finalResultEl.style.color = '#48bb78';
        } else if (bce > 1.0) {
          finalResultEl.style.color = '#f56565';
        } else {
          finalResultEl.style.color = '#ed8936';
        }
      }
    }

    // ===== ARCHITECTURE ANIMATION =====
    let architectureStep = 0;
    const architectureSteps = [
      { step: 'Etapa 1: Entrada da Imagem', layers: [1] },
      { step: 'Etapa 2: Primeira Convolução + ReLU + Pooling', layers: [2] },
      { step: 'Etapa 3: Segunda Convolução + ReLU + Pooling', layers: [3] },
      { step: 'Etapa 4: Terceira Convolução + ReLU + Pooling', layers: [4] },
      { step: 'Etapa 5: Flatten + Dense + Classificação', layers: [5] }
    ];

    function startArchitectureAnimation() {
      if (architectureAnimationRunning) return;
      architectureAnimationRunning = true;
      architectureStep = 0;
      
      for (let i = 1; i <= 5; i++) {
        const layerElements = document.querySelectorAll(`#layer${i} .layer-box`);
        layerElements.forEach(el => {
          el.classList.remove('active', 'processing');
        });
      }
      
      animateArchitectureStep();
    }

    function animateArchitectureStep() {
      if (architectureStep >= architectureSteps.length || !architectureAnimationRunning) {
        architectureAnimationRunning = false;
        return;
      }
      
      const currentStep = architectureSteps[architectureStep];
      const stepEl = document.getElementById('architectureStep');
      if (stepEl) stepEl.textContent = currentStep.step;
      
      currentStep.layers.forEach(layerIndex => {
        const layerElements = document.querySelectorAll(`#layer${layerIndex} .layer-box`);
        layerElements.forEach((el, index) => {
          setTimeout(() => {
            el.classList.add('processing');
            setTimeout(() => {
              el.classList.remove('processing');
              el.classList.add('active');
            }, 500);
          }, index * 300);
        });
      });
      
      architectureStep++;
      setTimeout(animateArchitectureStep, 2000);
    }

    function resetArchitectureAnimation() {
      architectureAnimationRunning = false;
      architectureStep = 0;
      const stepEl = document.getElementById('architectureStep');
      if (stepEl) stepEl.textContent = 'Etapa 1: Entrada da Imagem';
      
      for (let i = 1; i <= 5; i++) {
        const layerElements = document.querySelectorAll(`#layer${i} .layer-box`);
        layerElements.forEach(el => {
          el.classList.remove('active', 'processing');
        });
      }
    }

    // ===== RELU VISUALIZATION =====
    function drawReLUGraph() {
      const canvas = document.getElementById('reluCanvas');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw axes
      ctx.strokeStyle = '#9da7b3';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(50, canvas.height / 2);
      ctx.lineTo(canvas.width - 50, canvas.height / 2);
      ctx.moveTo(canvas.width / 2, 50);
      ctx.lineTo(canvas.width / 2, canvas.height - 50);
      ctx.stroke();
      
      // Labels
      ctx.fillStyle = '#9da7b3';
      ctx.font = '14px sans-serif';
      ctx.fillText('x', canvas.width - 40, canvas.height / 2 - 10);
      ctx.fillText('ReLU(x)', canvas.width / 2 + 10, 40);
      
      // Draw ReLU function
      ctx.strokeStyle = '#48bb78';
      ctx.lineWidth = 3;
      ctx.beginPath();
      
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const scale = 2;
      
      for (let x = -canvas.width / 2; x <= canvas.width / 2; x++) {
        const realX = x / scale;
        const reluY = Math.max(0, realX);
        const screenX = centerX + x;
        const screenY = centerY - reluY * scale;
        
        if (x === -canvas.width / 2) {
          ctx.moveTo(screenX, screenY);
        } else {
          ctx.lineTo(screenX, screenY);
        }
      }
      ctx.stroke();
    }

    function animateReLU() {
      drawReLUGraph();
      const canvas = document.getElementById('reluCanvas');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const scale = 2;
      
      let x = -canvas.width / 2;
      
      function animate() {
        if (x > canvas.width / 2) {
          drawReLUGraph();
          return;
        }
        
        const realX = x / scale;
        const reluY = Math.max(0, realX);
        const screenX = centerX + x;
        const screenY = centerY - reluY * scale;
        
        ctx.fillStyle = '#f56565';
        ctx.beginPath();
        ctx.arc(screenX, screenY, 5, 0, Math.PI * 2);
        ctx.fill();
        
        x += 2;
        setTimeout(animate, 10);
      }
      
      animate();
    }

    // ===== GRADIENT DESCENT ANIMATION =====
    function drawLossLandscape(ctx, width, height) {
      ctx.clearRect(0, 0, width, height);
      
      // Draw contour lines
      for (let level = 0; level < 10; level++) {
        ctx.strokeStyle = `rgba(121, 192, 255, ${0.1 + level * 0.05})`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        
        for (let angle = 0; angle < Math.PI * 2; angle += 0.1) {
          const r = 50 + level * 30;
          const x = width / 2 + r * Math.cos(angle) * 0.8;
          const y = height / 2 + r * Math.sin(angle) * 1.2;
          
          if (angle === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.closePath();
        ctx.stroke();
      }
      
      // Draw minimum point
      ctx.fillStyle = '#48bb78';
      ctx.beginPath();
      ctx.arc(width / 2, height / 2, 8, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.fillStyle = '#e6edf3';
      ctx.font = '12px sans-serif';
      ctx.fillText('Mínimo Global', width / 2 + 15, height / 2);
    }

    function lossFunction(x, y, centerX, centerY) {
      const dx = (x - centerX) / 100;
      const dy = (y - centerY) / 80;
      return dx * dx + dy * dy;
    }

    function gradient(x, y, centerX, centerY) {
      const dx = 2 * (x - centerX) / 10000;
      const dy = 2 * (y - centerY) / 6400;
      return { dx, dy };
    }

    let gdInterval;
    function startGD() {
      if (gdAnimationRunning) return;
      gdAnimationRunning = true;
      
      const canvas = document.getElementById('gdCanvas');
      const ball = document.getElementById('gdBall');
      if (!canvas || !ball) return;
      
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      
      drawLossLandscape(ctx, width, height);
      
      let x = width * 0.2;
      let y = height * 0.2;
      let iteration = 0;
      const learningRate = 800;
      
      ball.style.left = x + 'px';
      ball.style.top = y + 'px';
      
      gdInterval = setInterval(() => {
        if (!gdAnimationRunning) {
          clearInterval(gdInterval);
          return;
        }
        
        const centerX = width / 2;
        const centerY = height / 2;
        
        const loss = lossFunction(x, y, centerX, centerY);
        const grad = gradient(x, y, centerX, centerY);
        
        x -= learningRate * grad.dx;
        y -= learningRate * grad.dy;
        
        ball.style.left = x + 'px';
        ball.style.top = y + 'px';
        
        iteration++;
        document.getElementById('gdIteration').textContent = iteration;
        document.getElementById('gdLoss').textContent = loss.toFixed(3);
        
        // Trail effect
        ctx.fillStyle = 'rgba(245, 101, 101, 0.3)';
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, Math.PI * 2);
        ctx.fill();
        
        if (loss < 0.01 || iteration > 200) {
          clearInterval(gdInterval);
          gdAnimationRunning = false;
        }
      }, 50);
    }

    function resetGD() {
      gdAnimationRunning = false;
      if (gdInterval) clearInterval(gdInterval);
      
      const canvas = document.getElementById('gdCanvas');
      const ball = document.getElementById('gdBall');
      if (!canvas || !ball) return;
      
      const ctx = canvas.getContext('2d');
      drawLossLandscape(ctx, canvas.width, canvas.height);
      
      ball.style.left = (canvas.width * 0.2) + 'px';
      ball.style.top = (canvas.height * 0.2) + 'px';
      
      document.getElementById('gdIteration').textContent = '0';
      document.getElementById('gdLoss').textContent = '0.000';
    }

    // ===== ADAM OPTIMIZER ANIMATION =====
    let adamInterval;
    function startAdam() {
      if (adamAnimationRunning) return;
      adamAnimationRunning = true;
      
      const canvas = document.getElementById('adamCanvas');
      const ball = document.getElementById('adamBall');
      if (!canvas || !ball) return;
      
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      
      drawLossLandscape(ctx, width, height);
      
      let x = width * 0.2;
      let y = height * 0.2;
      let iteration = 0;
      let m_dx = 0, m_dy = 0;  // First moment
      let v_dx = 0, v_dy = 0;  // Second moment
      const beta1 = 0.9, beta2 = 0.999;
      const learningRate = 3000;
      const epsilon = 1e-8;
      
      ball.style.left = x + 'px';
      ball.style.top = y + 'px';
      
      adamInterval = setInterval(() => {
        if (!adamAnimationRunning) {
          clearInterval(adamInterval);
          return;
        }
        
        const centerX = width / 2;
        const centerY = height / 2;
        
        const loss = lossFunction(x, y, centerX, centerY);
        const grad = gradient(x, y, centerX, centerY);
        
        // Adam update
        m_dx = beta1 * m_dx + (1 - beta1) * grad.dx;
        m_dy = beta1 * m_dy + (1 - beta1) * grad.dy;
        v_dx = beta2 * v_dx + (1 - beta2) * grad.dx * grad.dx;
        v_dy = beta2 * v_dy + (1 - beta2) * grad.dy * grad.dy;
        
        const m_dx_hat = m_dx / (1 - Math.pow(beta1, iteration + 1));
        const m_dy_hat = m_dy / (1 - Math.pow(beta1, iteration + 1));
        const v_dx_hat = v_dx / (1 - Math.pow(beta2, iteration + 1));
        const v_dy_hat = v_dy / (1 - Math.pow(beta2, iteration + 1));
        
        x -= learningRate * m_dx_hat / (Math.sqrt(v_dx_hat) + epsilon);
        y -= learningRate * m_dy_hat / (Math.sqrt(v_dy_hat) + epsilon);
        
        ball.style.left = x + 'px';
        ball.style.top = y + 'px';
        
        iteration++;
        document.getElementById('adamIteration').textContent = iteration;
        document.getElementById('adamLoss').textContent = loss.toFixed(3);
        
        // Trail effect
        ctx.fillStyle = 'rgba(72, 187, 120, 0.3)';
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, Math.PI * 2);
        ctx.fill();
        
        if (loss < 0.01 || iteration > 200) {
          clearInterval(adamInterval);
          adamAnimationRunning = false;
        }
      }, 50);
    }

    function resetAdam() {
      adamAnimationRunning = false;
      if (adamInterval) clearInterval(adamInterval);
      
      const canvas = document.getElementById('adamCanvas');
      const ball = document.getElementById('adamBall');
      if (!canvas || !ball) return;
      
      const ctx = canvas.getContext('2d');
      drawLossLandscape(ctx, canvas.width, canvas.height);
      
      ball.style.left = (canvas.width * 0.2) + 'px';
      ball.style.top = (canvas.height * 0.2) + 'px';
      
      document.getElementById('adamIteration').textContent = '0';
      document.getElementById('adamLoss').textContent = '0.000';
    }

    // ===== COMPARISON ANIMATION =====
    let compInterval;
    function startComparison() {
      if (comparisonAnimationRunning) return;
      comparisonAnimationRunning = true;
      
      const canvas = document.getElementById('comparisonCanvas');
      const gdBall = document.getElementById('compGdBall');
      const adamBall = document.getElementById('compAdamBall');
      if (!canvas || !gdBall || !adamBall) return;
      
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      
      drawLossLandscape(ctx, width, height);
      
      // GD state
      let gd_x = width * 0.2, gd_y = height * 0.2;
      let gd_iteration = 0;
      const gd_lr = 800;
      
      // Adam state
      let adam_x = width * 0.2, adam_y = height * 0.2;
      let adam_iteration = 0;
      let m_dx = 0, m_dy = 0, v_dx = 0, v_dy = 0;
      const beta1 = 0.9, beta2 = 0.999;
      const adam_lr = 3000;
      const epsilon = 1e-8;
      
      gdBall.style.left = gd_x + 'px';
      gdBall.style.top = gd_y + 'px';
      adamBall.style.left = adam_x + 'px';
      adamBall.style.top = adam_y + 'px';
      
      const startTime = Date.now();
      let gd_converged = false;
      let adam_converged = false;
      let gd_time = 0;
      let adam_time = 0;
      
      compInterval = setInterval(() => {
        if (!comparisonAnimationRunning) {
          clearInterval(compInterval);
          return;
        }
        
        const centerX = width / 2;
        const centerY = height / 2;
        
        // Update GD
        if (!gd_converged) {
          const gd_loss = lossFunction(gd_x, gd_y, centerX, centerY);
          const gd_grad = gradient(gd_x, gd_y, centerX, centerY);
          
          gd_x -= gd_lr * gd_grad.dx;
          gd_y -= gd_lr * gd_grad.dy;
          
          gdBall.style.left = gd_x + 'px';
          gdBall.style.top = gd_y + 'px';
          
          gd_iteration++;
          
          ctx.fillStyle = 'rgba(245, 101, 101, 0.3)';
          ctx.beginPath();
          ctx.arc(gd_x, gd_y, 3, 0, Math.PI * 2);
          ctx.fill();
          
          if (gd_loss < 0.01 || gd_iteration > 200) {
            gd_converged = true;
            gd_time = ((Date.now() - startTime) / 1000).toFixed(1);
          }
        }
        
        // Update Adam
        if (!adam_converged) {
          const adam_loss = lossFunction(adam_x, adam_y, centerX, centerY);
          const adam_grad = gradient(adam_x, adam_y, centerX, centerY);
          
          m_dx = beta1 * m_dx + (1 - beta1) * adam_grad.dx;
          m_dy = beta1 * m_dy + (1 - beta1) * adam_grad.dy;
          v_dx = beta2 * v_dx + (1 - beta2) * adam_grad.dx * adam_grad.dx;
          v_dy = beta2 * v_dy + (1 - beta2) * adam_grad.dy * adam_grad.dy;
          
          const m_dx_hat = m_dx / (1 - Math.pow(beta1, adam_iteration + 1));
          const m_dy_hat = m_dy / (1 - Math.pow(beta1, adam_iteration + 1));
          const v_dx_hat = v_dx / (1 - Math.pow(beta2, adam_iteration + 1));
          const v_dy_hat = v_dy / (1 - Math.pow(beta2, adam_iteration + 1));
          
          adam_x -= adam_lr * m_dx_hat / (Math.sqrt(v_dx_hat) + epsilon);
          adam_y -= adam_lr * m_dy_hat / (Math.sqrt(v_dy_hat) + epsilon);
          
          adamBall.style.left = adam_x + 'px';
          adamBall.style.top = adam_y + 'px';
          
          adam_iteration++;
          
          ctx.fillStyle = 'rgba(72, 187, 120, 0.3)';
          ctx.beginPath();
          ctx.arc(adam_x, adam_y, 3, 0, Math.PI * 2);
          ctx.fill();
          
          if (adam_loss < 0.01 || adam_iteration > 200) {
            adam_converged = true;
            adam_time = ((Date.now() - startTime) / 1000).toFixed(1);
          }
        }
        
        // Update stats
        document.getElementById('compGdIterations').textContent = gd_iteration;
        document.getElementById('compAdamIterations').textContent = adam_iteration;
        document.getElementById('compGdTime').textContent = gd_time + 's';
        document.getElementById('compAdamTime').textContent = adam_time + 's';
        
        if (gd_converged && adam_converged) {
          clearInterval(compInterval);
          comparisonAnimationRunning = false;
        }
      }, 50);
    }

    function resetComparison() {
      comparisonAnimationRunning = false;
      if (compInterval) clearInterval(compInterval);
      
      const canvas = document.getElementById('comparisonCanvas');
      const gdBall = document.getElementById('compGdBall');
      const adamBall = document.getElementById('compAdamBall');
      if (!canvas || !gdBall || !adamBall) return;
      
      const ctx = canvas.getContext('2d');
      drawLossLandscape(ctx, canvas.width, canvas.height);
      
      gdBall.style.left = (canvas.width * 0.2) + 'px';
      gdBall.style.top = (canvas.height * 0.2) + 'px';
      adamBall.style.left = (canvas.width * 0.2) + 'px';
      adamBall.style.top = (canvas.height * 0.2) + 'px';
      
      document.getElementById('compGdIterations').textContent = '0';
      document.getElementById('compAdamIterations').textContent = '0';
      document.getElementById('compGdTime').textContent = '0.0s';
      document.getElementById('compAdamTime').textContent = '0.0s';
    }

    // ===== NETWORK DIAGRAM =====
    function initializeNetworkDiagram() {
      const svg = document.getElementById('networkDiagram');
      if (!svg) return;
      
      svg.innerHTML = '';
      
      const layers = [
        { name: 'Entrada', neurons: 4, x: 100 },
        { name: 'Oculta 1', neurons: 5, x: 350 },
        { name: 'Oculta 2', neurons: 5, x: 600 },
        { name: 'Saída', neurons: 2, x: 850 }
      ];
      
      // Draw connections
      const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      g.setAttribute('id', 'connections');
      
      for (let l = 0; l < layers.length - 1; l++) {
        const layer1 = layers[l];
        const layer2 = layers[l + 1];
        
        for (let i = 0; i < layer1.neurons; i++) {
          for (let j = 0; j < layer2.neurons; j++) {
            const y1 = 150 - (layer1.neurons - 1) * 25 + i * 50;
            const y2 = 150 - (layer2.neurons - 1) * 25 + j * 50;
            
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', layer1.x);
            line.setAttribute('y1', y1);
            line.setAttribute('x2', layer2.x);
            line.setAttribute('y2', y2);
            line.setAttribute('class', 'connection-line');
            line.setAttribute('data-from', `${l}-${i}`);
            line.setAttribute('data-to', `${l+1}-${j}`);
            g.appendChild(line);
          }
        }
      }
      svg.appendChild(g);
      
      // Draw neurons
      layers.forEach((layer, layerIdx) => {
        const layerGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        
        // Layer label
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', layer.x);
        text.setAttribute('y', 50);
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('fill', '#79c0ff');
        text.textContent = layer.name;
        layerGroup.appendChild(text);
        
        // Neurons
        for (let i = 0; i < layer.neurons; i++) {
          const y = 150 - (layer.neurons - 1) * 25 + i * 50;
          
          const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
          circle.setAttribute('cx', layer.x);
          circle.setAttribute('cy', y);
          circle.setAttribute('r', 20);
          circle.setAttribute('fill', '#4a5568');
          circle.setAttribute('stroke', '#6a7588');
          circle.setAttribute('stroke-width', '2');
          circle.setAttribute('class', 'network-node');
          circle.setAttribute('data-layer', layerIdx);
          circle.setAttribute('data-neuron', i);
          layerGroup.appendChild(circle);
        }
        
        svg.appendChild(layerGroup);
      });
    }

    function animateNetwork() {
      const nodes = document.querySelectorAll('.network-node');
      const connections = document.querySelectorAll('.connection-line');
      
      nodes.forEach(node => node.classList.remove('active'));
      connections.forEach(conn => conn.classList.remove('active'));
      
      let currentLayer = 0;
      const maxLayer = 3;
      
      function activateLayer() {
        if (currentLayer > maxLayer) return;
        
        // Activate current layer neurons
        const layerNodes = document.querySelectorAll(`[data-layer="${currentLayer}"]`);
        layerNodes.forEach((node, idx) => {
          setTimeout(() => {
            node.classList.add('active');
          }, idx * 100);
        });
        
        // Activate connections to next layer
        if (currentLayer < maxLayer) {
          setTimeout(() => {
            const conns = document.querySelectorAll(`[data-from^="${currentLayer}-"]`);
            conns.forEach((conn, idx) => {
              setTimeout(() => {
                conn.classList.add('active');
              }, idx * 10);
            });
          }, layerNodes.length * 100);
        }
        
        currentLayer++;
        setTimeout(activateLayer, 1000);
      }
      
      activateLayer();
    }

    function resetNetwork() {
      const nodes = document.querySelectorAll('.network-node');
      const connections = document.querySelectorAll('.connection-line');
      
      nodes.forEach(node => node.classList.remove('active'));
      connections.forEach(conn => conn.classList.remove('active'));
    }

    // ===== FLOWCHART DIAGRAM =====
    function initializeFlowchart() {
      const svg = document.getElementById('flowchartDiagram');
      if (!svg) return;
      
      svg.innerHTML = '';
      
      const steps = [
        { text: 'Sinal EA', x: 150, y: 100 },
        { text: 'STFT', x: 150, y: 200 },
        { text: 'Espectrograma', x: 150, y: 300 },
        { text: 'CNN', x: 500, y: 200 },
        { text: 'Classificação', x: 850, y: 200 }
      ];
      
      // Draw arrows
      const arrows = [
        { from: 0, to: 1 },
        { from: 1, to: 2 },
        { from: 2, to: 3 },
        { from: 3, to: 4 }
      ];
      
      arrows.forEach(arrow => {
        const from = steps[arrow.from];
        const to = steps[arrow.to];
        
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', from.x);
        line.setAttribute('y1', from.y + 30);
        line.setAttribute('x2', to.x);
        line.setAttribute('y2', to.y - 30);
        line.setAttribute('stroke', '#79c0ff');
        line.setAttribute('stroke-width', '3');
        line.setAttribute('marker-end', 'url(#arrowhead)');
        svg.appendChild(line);
      });
      
      // Draw boxes
      steps.forEach((step, idx) => {
        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        rect.setAttribute('x', step.x - 80);
        rect.setAttribute('y', step.y - 30);
        rect.setAttribute('width', 160);
        rect.setAttribute('height', 60);
        rect.setAttribute('fill', '#2d3748');
        rect.setAttribute('stroke', '#4a5568');
        rect.setAttribute('stroke-width', '2');
        rect.setAttribute('rx', '5');
        rect.setAttribute('data-step', idx);
        svg.appendChild(rect);
        
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', step.x);
        text.setAttribute('y', step.y + 5);
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('fill', '#e6edf3');
        text.textContent = step.text;
        svg.appendChild(text);
      });
      
      // Define arrowhead marker
      const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
      const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
      marker.setAttribute('id', 'arrowhead');
      marker.setAttribute('markerWidth', '10');
      marker.setAttribute('markerHeight', '10');
      marker.setAttribute('refX', '9');
      marker.setAttribute('refY', '3');
      marker.setAttribute('orient', 'auto');
      
      const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
      polygon.setAttribute('points', '0 0, 10 3, 0 6');
      polygon.setAttribute('fill', '#79c0ff');
      marker.appendChild(polygon);
      defs.appendChild(marker);
      svg.insertBefore(defs, svg.firstChild);
    }

    function animateFlowchart() {
      const boxes = document.querySelectorAll('[data-step]');
      boxes.forEach((box, idx) => {
        setTimeout(() => {
          box.setAttribute('fill', '#48bb78');
          setTimeout(() => {
            box.setAttribute('fill', '#2d3748');
          }, 500);
        }, idx * 1000);
      });
    }

    function resetFlowchart() {
      const boxes = document.querySelectorAll('[data-step]');
      boxes.forEach(box => {
        box.setAttribute('fill', '#2d3748');
      });
    }
  </script>
</body>
</html>